import numpy as np



'''
    PROCESS INPUTS

    The inputs is arranged into an adjacency list, with a dictionary that stores 
    a numerical code for each bag.
'''

# Open and parse input text
with open("bags.txt", "r") as f:
    raw_lines = f.read()

# Simply split the lines up
# Actual parsing is involved in creating the adjacency list
raw_information = raw_lines.split("\n")

# Contains information about which bags contain which
bags = dict()

# Used as reference for each bag's index code
bag_code = dict()
number_of_bags = 0

for bag_information in raw_information:
    # Retrieve the name of the bigger bag
    bag_container, split_information = bag_information.split(" bags contain ")

    contained_bags = dict()

    # Process information about the contained bags
    for each_bag_information in split_information.split(", "):
        # Split the number from the bag name
        each_bag = each_bag_information.split()

        # As long as the phrase doesn't end in "no other bags"
        if each_bag[0] != "no":
            # Collect information
            each_bag_number = each_bag[0]
            each_bag_name = " ".join(each_bag[1:3])

            # Store information
            contained_bags[each_bag_name] = each_bag_number

    bags[bag_container] = contained_bags

    # Store bag code
    # Note that it's assumed every line contains a new type of bag
    bag_code[bag_container] = number_of_bags
    number_of_bags += 1



'''
    PART 1 + 2: FIND SHINY GOLD BAG PATH

    In this algorithm:
        - Nodes represent bags
        - Directed edges represent the ability for bags to be contained
        - Weights of edges represent how many bags can be contained

    For example, if there is an edge E of weight 3 leading from node A to node B 
    (A --> B), this means that 3 bags of B can be contained in bag A. The source 
    node (the node with where the edge is directed outwards from) is the parent 
    node, i.e. the larger bag.

    To further this definition, if there exists a path from node A to node B, 
    this means that bag B can somehow be contained in bag A. The importance of 
    this definition is that A and B don't have to be directly adjacent. For 
    example, a path such as A --> C --> D --> B is still a path from node A to 
    node B; however, translating this to language:

        "Bag B can be contained in bag D, contained in bag C, contained in bag 
        A; thus, bag B can be contained in bag A."

    This still means that bag B can somehow be contained in bag A.

    Using these definitions, the problem can be re-defined:
        - PART 1: Find the total number of UNIQUE BAGS in which there exists a 
                  path ENDING with the shiny gold bag.
        - PART 2: Find the total number of PATHS in which there exists a path 
                  STARTING with the shiny gold bag.

    In either case, the problem involves finding a path between any two nodes.
    Using a theorem from graph theory, the algorithm below calculates the total 
    number of paths between every single node of a certain path length n. The 
    algorithm iterates through path lengths n = 1, 2, ... until it determines 
    that there are no more possible paths leading in or out of the shiny gold 
    bag.

    Note that the theorem technically calculates walks (walks are paths that can 
    have repeated vertices), but since the graph generated by this problem is a 
    tree, every walk is a path, since cycles don't exist.
'''

# Create adjacency list
# Rows store which bags the row-bag contains
# Columns store which bags contain the column-bag
adjacency_matrix = np.zeros((number_of_bags, number_of_bags), dtype=int)

# Iterate through bag dictionary
for bag_container in bags.keys():
    # Retrieve bag code
    parent = bag_code[bag_container]

    for contained_bag in bags[bag_container]:
        # Retrieve bag code
        child = bag_code[contained_bag]

        # There exists a path from parent to child bag
        adjacency_matrix[parent][child] = bags[bag_container][contained_bag]

# Keep track of the node number of shiny gold bag
source_node = bag_code["shiny gold"]

# Keep track of last recorded number of paths leading into and out of shiny gold 
# bag, used to track when to end the algorithm
# Initially set it to -1 to allow the while loop to enter
previous_incoming = -1
previous_outgoing = -1

# Keep track of total number of outgoing paths leading out of shiny gold bag
total_outgoing = 0

# Keep track of all bags 
# Set to guarantee uniqueness
bags_incoming = set()

# Initialize matrix to calculate the current power
temp_matrix = adjacency_matrix

# Perform the walk-length algorithm
# Will only be ended when there are neither incoming nor outgoing paths from
# shiny gold bag
while (previous_incoming != 0) or (previous_outgoing != 0): 
    # PART 1: COLUMN
    # Calculate the total number of unique bags leading into shiny gold bag
    current_incoming = 0

    # Incoming paths (column vector)
    adjacent_column = temp_matrix[:,source_node]

    for (adjacent_bag, adjacency) in enumerate(adjacent_column):
        # Check for adjacency
        if adjacency != 0:
            current_incoming += 1

            # Push the bag number
            bags_incoming.add(adjacent_bag)



    # PART 2: ROW
    # Calculate the total number of paths that lead from shiny gold bag
    current_outgoing = 0

    # Outgoing paths (row vector)
    adjacent_row = temp_matrix[source_node,:]

    for (adjacent_bag, adjacency) in enumerate(adjacent_row):
        # Since the adjacency measures how many paths lead from the shiny gold 
        # bag to the adjacent bag, add it to the total outgoing paths from the 
        # shiny gold bag
        total_outgoing += adjacency

        # Check for adjacency
        if adjacency != 0:
            current_outgoing += 1



    # Update last amount of incoming and outgoing paths
    previous_incoming = current_incoming
    previous_outgoing = current_outgoing

    # Raise the power of the adjacency matrix to calculate for a longer path
    # This is the part of the algorithm that relies on the graph theorem
    temp_matrix = np.matmul(temp_matrix, adjacency_matrix)

# PART 1 + 2
print(len(bags_incoming), total_outgoing)